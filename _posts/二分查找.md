---
title: 二分查找
date: 2020-12-31 00:19:36
tags:
  - CLRS
---
`二分查找`（Binary Search）算法，也叫折半查找算法。二分查找的思想非常简单，很多非计算机专业的同学很容易就能理解，但是看似越简单的东西往往越难掌握好，想要灵活应用就更加困难。

## 无处不在的二分思想
我们现在来做一个猜字游戏：我随机写一个 0 到 99 之间的数字，然后你来猜我写的是什么。猜的过程中，你每猜一次，我就会告诉你猜的大了还是小了，直到猜中为止。假设我写的数字是 23，你可以按照下面的步骤来试一试：
![](https://raw.githubusercontent.com/was48i/mPOST/master/CLRS/geek/68.png)
<!--more-->

假设有 1000 条订单数据，已经按照订单金额从小到大排序，每个订单金额都不同，并且最小单位是元。我们现在想知道是否存在金额等于 19 元的订单。如果存在，则返回订单数据，如果不存在则返回 null。为了方便讲解，我们假设只有 10 个订单，订单金额分别是：8, 11, 19, 23, 27, 33, 45, 55, 67, 98。还是利用二分思想，每次都与区间的中间数据比对大小，缩小查找区间的范围。为了更加直观，我画了一张查找过程的图。其中，low 和 high 表示待查找区间的下标，mid 表示待查找区间的中间元素下标：
![](https://raw.githubusercontent.com/was48i/mPOST/master/CLRS/geek/69.png)

二分查找针对的是一个**有序的数据集合**，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，**直到找到要查找的元素，或者区间被缩小为 0**。

## O(logn) 惊人的查找速度
我们假设数据大小是 n，每次查找后数据都会缩小为原来的一半，也就是会除以 2。最坏情况下，直到查找区间被缩小为空，才停止：
![](https://raw.githubusercontent.com/was48i/mPOST/master/CLRS/geek/69.png)

可以看出来，这是一个等比数列。其中 n/2^k=1 时，k 的值就是总共缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以，**经过了 k 次区间缩小操作，时间复杂度就是 O(k)**。通过 n/2^k=1，我们可以求得 k=log2n，所以时间复杂度就是 O(logn)。

logn 是一个非常恐怖的数量级，即便 n 非常非常大，对应的 logn 也很小。比如 n 等于 2 的 32 次方，这个数很大了吧？大约是 42 亿。也就是说，如果我们在 42 亿个数据中用二分查找一个数据，最多需要比较 32 次。我们前面讲过，用大 O 标记法表示时间复杂度的时候，会省略掉常数、系数和低阶。对于常量级时间复杂度的算法来说，O(1) 有可能表示的是一个非常大的常量值，比如 O(1000)、O(10000)。所以，**常量级时间复杂度的算法有时候可能还没有 O(logn) 的算法执行效率高**。

> 指数时间复杂度的算法在大规模数据面前是无效的

## 二分查找的递归与非递归实现



## 二分查找应用场景的局限性

## 如何在 1000 万个整数中快速查找某个整数
