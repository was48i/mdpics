---
title: 编译和链接
date: 2018-11-14 17:51:47
tags:
  - DevPrepares
---
集成开发环境（IDE）一般都将编译和链接的过程一步完成，将这种编译和链接合并到一起的过程称为`构建（Build）`。
我们看到的是这些问题的现象，但是却很难看清本质，所有这些问题的本质就是软件运行背后的机理及支撑软件运行的各种平台和工具。
## 被隐藏了的过程
分解为 4 个步骤，分别是：**预处理**（Preprocessing）、**编译**（Compilation）、**汇编**（Assembly）和**链接**（Linking）。
![](https://raw.githubusercontent.com/was48i/mPOST/master/DevPrepares/2-1.jpeg)
<!--more-->
### 预处理
```
$ gcc -E hello.c -o hello.i
```
经过预处理后的 \*.i 文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到 \*.i 文件中。
当我们无法判断宏定义是否正确或头文件包含是否正确时，可以查看预编译后的文件来确定问题。
### 编译
编译过程就是把预处理完的文件进行一系列的词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。
```
$ gcc -S hello.i -o hello.s
```
现在版本的 GCC 把预编译和编译两个步骤合并成一个步骤，实际上 `gcc 命令`只是这些后台程序的包装，它会根据**不同参数**去调用编译器 cc1、汇编器 as、链接器 ld。
### 汇编
汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎对应一条机器指令。
```
$ as hello.s -o hello.o
```
### 链接
要将一大堆文件链接起来才可以得到“a.out”，即最终的可执行文件。
## 编译器做了什么
编译器就是将高级语言翻译成机器语言的一个工具。高级编程语言的出现使得程序开发的效率大大提高，高级语言的可移植性也使得它在多种计算机平台下能够游刃有余。
编译过程一般可以分为 6 步：词法分析、语法分析、语义分析、源代码优化、代码生成和目标代码优化，即从**源代码**（Source Code）到**最终目标代码**（Final Target Code）的过程。
![](https://raw.githubusercontent.com/was48i/mPOST/master/DevPrepares/2-2.jpeg)
### 词法分析
源代码程序被输入到**扫描器**（Scanner），简单地进行词法分析，运用一种类似于**有限状态机**（Finite State Machine）的算法可以很轻松地将源代码的字符序列分割成一系列的**记号**（Token）。
在识别记号的同时，扫描器也完成了其他工作。比如将标识符存放到符号表，将数字、字符串常量存放到文字表等，以备后面的步骤使用。
使用 `lex 工具`，无须为每个编译器开发一个独立的词法扫描器，而是根据需要改变词法规则就可以了。
### 语法分析
**语法分析器**（Grammar Parser）将对由扫描器产生的记号进行语法分析，从而产生**语法树**（Syntax Tree）。整个分析过程采用了**上下文无关语法**（Context-free Grammar）。
简单地讲，由语法分析器生成的语法树就是以**表达式**（Expression）为节点的树。
![](https://raw.githubusercontent.com/was48i/mPOST/master/DevPrepares/2-3.jpeg)
使用 `yacc 工具`，只须改变语法规则，而无须为每个编译器编写一个语法分析器。所以它又被称为“编译器编译器（Compiler Compiler）”。
### 语义分析
语义分析由**语义分析器**（Semantic Analyzer）来完成，语法分析仅仅是完成了对表达式的语法层面的分析，但是它并不了解这个语句是否真正有意义。
编译器所能分析的语义是**静态语义**（Static Semantic），所谓静态语义是指在编译期可以确定的语义，与之对应的**动态语义**（Dynamic Semantic）就是只有在运行期才能确定的语义。
经过语义分析阶段以后，整个语法树的表达式都被标识了类型。
### 中间语言生成
**源码级优化器**（Source Code Optimizer）在不同编译器中可能会有不同的定义或有一些其他的差异。所以，源代码优化器往往将整个语法树转换成**中间代码**（Intermediate Code），它是语法树的顺序表示，已经非常接近目标代码了。
`编译器前端`负责产生机器无关的中间代码，`编译器后端`将中间代码转换成目标机器代码。这样对于一些可以跨平台的编译器而言，它们可以针对不同的平台使用同一个前端和数个后端。
中间代码比较常见的形式有：**三地址码**（Three-address Code）和 **P-代码**（P-Code）。
### 目标代码生成与优化
编译器后端主要包括**代码生成器**（Code Generator）和**目标代码优化器**（Target Code Optimizer）。代码生成器将中间代码转换成目标机器码，目标代码优化器对上述的目标代码进行优化。
事实上，定义在其他模块的全局变量和函数在最终运行时的绝对地址，都要在最终链接的时候才能确定。现代的编译器可以将一个源代码文件编译成一个**未链接的**目标文件，然后由链接器最终将这些目标文件链接起来形成可执行文件。
## 链接器年龄比编译器长
汇编语言使用接近人类的各种符号和标记来帮助记忆。`符号（Symbol）`这个概念随着汇编语言的普及迅速被使用，它用来表示一个地址，这个地址可能是一段子程序（后来发展成**函数**）的起始地址，也可以是一个**变量**的起始地址。
在比较高级的语言中，如 Java 中，每个类是一个基本的模块，若干个模块组成一个**包**（Package），若干个包组合成一个程序。
模块之间如何组合的问题可以归结为模块之间如何通信的问题，最常见的通信有两种方式：
- 模块间的函数调用
- 模块间的变量访问

这两种方式可以归结为一种方式，即模块间符号的引用。
基于符号的模块化的一个直接结果是：`链接（Linking）`过程在整个程序开发中变得十分重要和突出。
## 模块拼装——静态链接
链接的主要内容就是把各个模块之间相互引用的部分都处理好，使得各个模块之间能够正确地衔接。链接过程主要包括了**地址和空间分配**（Address and Storage Allocation）、**符号决议**（Symbol Resolution）和**重定位**（Relocation）等这些步骤。
目标文件和**库**（Library）一起链接形成最终可执行文件，库其实是一组目标文件的包。最常见的库就是**运行时库**（Runtime Library），它是支持程序运行的基本函数的集合。
地址修正的过程也被叫做重定位，每个要被修正的地方叫一个**重定位入口**（Relocation Entry）。重定位所做的就是给程序中每个这样的绝对地址引用的位置“打补丁”，使它们指向正确的地址。
